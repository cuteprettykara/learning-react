컨트롤러는 모델 데이터를 조회하거나 수정하고, 변경된 사항을 뷰에 반영합니다.
반영하는 과정에서 보통 뷰를 변형(mutate)하지요.

뷰를 변형하는 과정은
* 애플리케이션 규모가 크면 상당히 [복잡]해지고,
* 제대로 관리하지 않으면 [성능]도 떨어질 수 있습니다.

페이스북 개발팀에서 이를 해결하려고 고안한 이이디어가 있는데,
* 어떤 데이터가 변할 때마다 어떤 변화를 줄지 고민하는 것이 아니라,
* 그냥 기존 뷰를 날려버리고, 처음부터 새로 렌더링하는 방식입니다.

이렇게 하면
* 애플리케이션 구조가 매우 간단하고,
* 작성해야 할 코드양도 많이 줄어듭니다.

* 더 이상 어떻게 변화를 줄지 신경 쓸 필요가 없고,
* 그저 뷰가 어떻게 생길지 선언하며,
* 데이터에 변화가 있으면 기존에 있던 것은 버리고, 새로 렌더링하면 되니까요.

그런데 이것이 과연 될까요? 웹 브라우저에서 이 방식대로 하면
* CPU 점유율도 많이 잡아먹을 텐데요. DOM은 느리니까요.
* 메모리도 많이 사용할 것이고요.
* 유저가 Input 박스에 텍스트를 입력할 때 기존 렌더링된 것은 사라지고, 새로 렌더링하면 끊김 현상이 발생할 것입니다.

페이스북 개발팀이 앞서 설명한 방식으로
* 최대한 성능을 아끼고
* 편안한 유저 경험(user experience)을 제공하면서 구현하려고 개발한 것이 바로 리액트입니다.

리액트는 오직 View만 신경 쓰는 라이브러리입니다.

리액트 프로젝트에서 특정 부분이 어떻게 생길지 정하는 선언체가 있는데, 이를 컴포넌트(component)라고 합니다.
컴포넌트는 템플릿과는 다른 개념입니다. 템플릿은 보통 데이터셋이 주어지면 HTML 태그 형식을 문자열로 반환하는데,
이와 달리 컴포넌트는 조금 더 복합적인 개념입니다.

컴포넌트 = 생김새 + 작동 방식

[초기 렌더링]
render() { ... } 함수가 담당.

* 이 함수는 컴포넌트가 어떻게 생겼는지 정의하는 역할을 담당.
* 이 함수는 html 형식의 문자열을 반환하지 않고, 뷰가 어떻게 생겼고, 어떻게 작동되는지의 정보를 지닌 [객체를 반환]

★ render 함수는 객체를 반환한다.

render 함수를 실행하면 내부에 있는 컴포넌트들도 재귀적으로 렌더링합니다.
1. 최상위 컴포넌트의 렌더링 작업이 끝나면(-> 객체 반환),
2. 지니고 있는 정보들을 사용하여 HTML 마크업을 만들고,
3. 이를 DOM 요소 안에 주입합니다.

[조화 과정]
리액트에서 뷰를 업데이트 할 때는 "조화 과정(reconciliation)을 거친다"라고 표현한다.

이 작업 또한 render() { ... } 함수가 담당.

컴포넌트는 데이터를 업데이트했을 때,
* 단순히 업데이트한 값을 수정하는 것이 아니라,
* 새로운 데이터를 가지고 render() 함수를 또 [다시 호출]합니다.

그러면 그 데이터를 지닌 뷰를 생성해 내겠죠?
이때, render() 함수가 반환하는 결과를 곧바로 DOM에 반영하지 않고,
이전에 render() 함수가 만들었던 컴포넌트 정보와 현재 render() 함수가 만든 컴포넌트 정보를 비교합니다.

자바스크립트를 사용하여 두 가지 뷰를 [최소한의 연산]으로 비교한 후, 둘의 차이를 알아내 DOM 트리를 업데이트 합니다.