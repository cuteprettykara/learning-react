리덕스를 사용하여 멀티 카운터를 만들면서 조금은 불편했습니다.
* 액션을 만들 때마다 세 가지 파일(액션 타입, 액션 생성 함수, 리듀서)을 수정해야 한다는 점,
* 전개 연산자와 slice 함수로 배열 내부의 원소를 수정하는데 [가독성]이 낮다는 점

이 장에서는 이런 불편한 점을 해결하여 더욱 편하게 리덕스를 사용하는 방법을 알아보겠습니다.
* Immutable.js를 이용한 상태 업데이트
* Ducks 파일 구조
* redux-actions를 이용하여 더욱 쉽게 액션 생성함수 만들기

● 객체 불변성
  리액트 컴포넌트는 state 또는 상위 컴포넌트로부터 전달받은 props 값이 변할 때 렌더링되는데,
  배열이나 객체를 직접 수정한다면, [레퍼런스가 가리키는 곳은 같기 때문에] 똑같은 값으로 인식합니다.

  이런 이슈 때문에 여러 층으로 구성된 객체나 배열을 업데이트할 때, 전개 연산자를 사용해서
  기존 값을 가진 새 객체 또는 배열을 만들었던 것입니다.

  하지만 그렇게 작업하다 보면 간단한 변경을 구현하는 데도 코드가 복잡해질 수가 있습니다.
  예를 들어 수정해야 할 값이 객체의 깊은 곳에 위치한다면...

  let object1 = {
    a: 1,
    b: 2,
    c: 3,
    d: {
      e: 4,
      f: {
        g: 5,
        h: 6
      }
    }
  };

  // h값을 10으로 업데이트합니다.
  let object2 = {
    ...object1,
    d: {
      ...object1.d,
      f: {
        ...object1.d.f,
        h: 10
      }
    }
  }

  => 객체 불변성을 유지할 필요가 없다면 다음과 같이 간단하게 해도 되는데 말입니다.
     object1.d.f.h = 10;

  배열을 다룰 때도 마찬가지입니다. 수정하려는 원소 위치의 전후를 slice로 가져와야 하는데, 꽤나 귀찮은 작업입니다.

  이런 작업들을 간소화하려고 페이스북 팀이 만든 라이브러리가 바로 Immutable.js입니다.
  이 라이브러리를 사용하면 이 코드는 다음 형식으로 작성할 수 있습니다.

  let object1 = Map({
    a: 1,
    b: 2,
    c: 3,
    d: Map({
      e: 4,
      f: Map({
        g: 5,
        h: 6
      })
    })
  });
  let object2 = object1.setIn(['d', 'f', 'h'], 10);
  object1 === object2 // false